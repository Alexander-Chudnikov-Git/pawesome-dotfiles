#!/bin/bash

# Define an array of labels
labels=("К преимуществам СБД по сравнению с прочими .. Освобождение пользователя от администрирования данных | Верно" \
        "Язык определения данных – это | DDL" \
        "Уровень абстракции, описывающий некоторую часть данных | Уровень «представлений»" \
        "К преимуществам СБД по сравнению .. Избыточность данных | Неверно" \
        "Организованная на машинном носителе совокупность взаимосвязанных данных | БД" \
        "К преимуществам СБД по сравнению с прочими .. Поддержание систем безопасности данных | Верно" \
        "База данных как совокупность таблиц, в каждой из которых хранится информация | Концептуального уровня" \
        "Структура таблицы определяется составом полей. Каждое поле отражает определённую | Физического уровня" \
        "Компонент СБД, который перевод инструкции | Процессор запросов" \
        "К преимуществам СБД по сравнению с прочими .. Зависимость прикладных программ | Неверно" \
        "Cистема, специальным образом организованных данных | СБД" \
        "Признак, характеризующий сущность БД – это | Атрибут" \
        "Модель данных, где используется представление базы данных в виде древовидной | Иерархическая модель" \
        "Верно ли полагать следующее: Реляционная алгебра замкнута на множестве отношений | Верно / True" \
        "Строка реляционной таблицы, которая содержит данные | Запись" \
        "Верно ли: Первичный ключ не обязательно является супер-ключом | Неверно / False" \
        "Верно ли: Отношение – набор упорядоченных кортежей, состоящих из набора характеристик объекта | Неверно / False" \
        "Модель данных, состоящая из набора таблиц, описывающих данные и отношения между данными | Реляционная модель" \
        "Подмножество атрибутов отношения, удовлетворяющее требованию уникальности | Superkey (супер-ключ)" \
        "Верно ли: Атрибут кортежа – множество упорядоченных пар <Название, Тип> | Неверно / False" \
        "Основная логическая структурная единица манипулирования данными в реляционной модели | Запись" \
        "Верно ли: Кортеж – множество упорядоченных троек <Название, Тип, Значение> | Верно / True" \
        "Кардинальность результата: A INTERSECT B{ALL BUT atr_2} | 0 мой ответ, но -1 помечен как правильный?" \
        "Какие операции реляционной алгебры не являются унарными? | Декартово произведение, Пересечение, Соединение, Разность, Объединение" \
        "Исчисление кортежей является | Процедурным языком запросов" \
        "Укажите в ответе кардинальность: A UNION B{ALL BUT atr_3} | 6" \
        "Укажите в ответе кардинальность: A{atr_1} MINUS B{atr_1} | 0" \
        "Верно ли о термине реляционной модели «отношение»: Отношение не содержит одинаковых атрибутов | Верно / True" \
        "Верно ли о термине реляционной модели «отношение»: Каждый атрибут отношения содержит строго одно значение своего типа | Неверно / False" \
        "Верно ли о термине реляционной модели «отношение»: Отношение не может содержать кортежи, у которых совпадают типы атрибутов | Неверно / False" \
        "Перед выполнением система проверяет, имеют ли операнды типы, допустимые для использования – этот подход носит название | Строгая типизация" \
        "Какие операции реляционной алгебры являются выводимыми | Пересечение, Соединение" \
        "Пусть A(a1, …, an) и B(b1, …, bk). – Объединения A UNION B? | 1) Одинаковая арность отношений, 2) Домены атрибутов должны быть совместимы" \
        "Полный набор упорядоченных пар <Название(i), Тип(i)> - это | Заголовок кортежа" \
        "К какой группе операторов языка SQL относится INSERT | DML" \
        "Orders, где SELECT snum, MAX(amt) FROM Orders GROUP BY | Поле odate не может быть использовано в предложении HAVING, имеет больше, чем значение на группу вывода" \
        "Фраза WHERE команды SELECT реализует реляционную операцию | Выборки (сокращения)"\
        "аблица Table состоит из полей Field1 и Field2. Запрос | 1) SELECT * FROM Table, 2) SELECT ALL Field1, Field2 FROM Table AS t" \
        "Фраза SELECT реализует реляционную операцию | Проекции" \
        "Table состоит только из поля Field. | 1) SELECT FROM Table, 2) SELECT ALL FROM Table AS Name1, Table AS Name2, 3) SELECT Field.Table FROM Table" \
        "Чтобы определить глобальную переменную в MS SQL DECLARE @@MyVar INT | Неверно / False" \
        "Реляционная операция выборки реализуется в команде SELECT посредством | 1) Фразы HAVING, 2) перечня имён объектов во фразе SELECT, 3) фразы WHERE" \
        "Почему индексы строят не по каждому атрибуту | 1) Использование индексов вызывает дополнительные затраты времени" \
        "на выполнение операций ввода-вывода при вставке / удалении данных, 2) индексы требуют выделения памяти для их размещения" \
        "В MS SQL кластеризованный индекс создаётся по умолчанию при создании ограничения | Неверно / False" \
        "К какой группе операторов языка SQL относится ALTER | DDL" \
        "Что такое Хранилище данных? | Сервер БД позволяет хранить большие объёмы данных" \
        "В MS SQL в хранимых процедурах в отличие от функций могут быть | Верно / True"\
        "Дана таблица Customers, где | SELECT rating, COUNT(*) FROM Customers GROUP BY rating HAVING COUNT(*) = 3"\
        "В MS SQL представления можно использовать для изменения данных в базовых  | Верно / True")

# Get the current label index
if [ -f /tmp/label_index ]; then
    # Get the current label index
    current_label_index=$(cat /tmp/label_index)
else
    # If the file doesn't exist, set the index to 0
    current_label_index=0
fi

# Get the current label index
if [ -f /tmp/label_hide ]; then
    # Get the current label index
    current_label_hide=$(cat /tmp/label_hide)
else
    # If the file doesn't exist, set the index to 0
    current_label_hide=0
fi

# Check if --next option is passed
if [ "$1" == "--next" ]; then
    # Calculate the index of the next label
    next_label_index=$(( ($current_label_index + 1) % ${#labels[@]} ))

    # Save the index of the next label
    echo $next_label_index > /tmp/label_index
elif [ "$1" == "--prev" ]; then
    # Calculate the index of the previous label
    prev_label_index=$(( ($current_label_index - 1 + ${#labels[@]}) % ${#labels[@]} ))

    # Save the index of the previous label
    echo $prev_label_index > /tmp/label_index
elif [ "$1" == "--hide" ]; then
    # Calculate the index of the previous label
    next_label_hide=$(( ($current_label_hide + 1) % 2 ))

    # Save the index of the previous label
    echo $next_label_hide > /tmp/label_hide
else
    # Output the current label
    if [ $current_label_hide -eq 0 ]; then
        echo "${labels[$current_label_index]}"
    else
        echo "Firefox - Protect your life online with privacy-first products ..."
    fi
fi

